Задачи на урок:
Разбор и обсуждение домашнего задания
Исключения в Джава, окончание
Практика, мини проект Садовод-любитель
Исключения
Огромная часть работы программиста — это работа с ошибками. Причем чаще всего — со своими собственными.

Так уж сложилось, что не бывает людей, которые не допускают ошибок. И программ таких тоже не бывает.

Конечно, главное при работе над ошибкой — понять ее причину. А причин таких в программе может быть целая куча.

В один прекрасный момент перед создателями Java встал вопрос: что делать с этими самыми потенциальными ошибками в программах? Избежать их полностью — нереально. Программисты могут понаписать такого, что невозможно даже представить :)

Значит, надо заложить в язык механизм работы с ошибками. Иными словами, если уж в программе произошла какая-то ошибка, нужен сценарий для дальнейшей работы. Что именно программа должна делать при возникновении ошибки?

Сегодня мы познакомимся с этим механизмом. И называется он “Исключения” (Exceptions).

Разновидности исключений
IOException
ArithmeticException
ArrayIndexOutOfBoundsException
NumberFormatException

Вид сообщений об ошибке
Exception in thread "main" java.lang.ArithmeticException: / by zero at Task.main(Task.java:15)

В сообщений об ошибки Java указывает:

название ошибки (обычно понятное — ArithmeticException, например),
дополнительную информацию (/ by zero),
класс и метод (Task.main)
файл и номер строки с ошибкой (Task.java:15)

Перехват и обработка исключений
Для работы с исключениями в Java существуют специальные блоки кода: try, catch и finally.

Код, в котором программист ожидает возникновения исключений, помещается в блок try. Это не значит, что исключение в этом месте обязательно произойдет. Это значит, что оно может там произойти, и программист в курсе этого.

Тип ошибки, который ты ожидаешь получить, помещается в блок catch (“перехват”). Сюда же помещается весь код, который нужно выполнить, если исключение произойдет.

try {
System.out.println("Делим число на ноль");
System.out.println(366/0);//в этой строчке кода будет выброшено исключение
} catch (ArithmeticException e) {
System.out.println("Ошибка! Нельзя делить на ноль!");
}

Поведение исключений
Как только в какой-то строчке кода в блоке try возникнет исключение, код после нее уже не будет выполнен. Выполнение программы сразу “перепрыгнет” в блок catch.

try {
System.out.println("Делим число на ноль");
System.out.println(366/0);//в этой строчке кода будет выброшено исключение
System.out.println("Этот");
System.out.println("код");
System.out.println("не");
System.out.println("будет");
System.out.println("выполнен!");
} catch (ArithmeticException e) {
System.out.println("Программа перепрыгнула в блок catch!");
System.out.println("Ошибка! Нельзя делить на ноль!");
}
Вывод:

Делим число на ноль
Программа перепрыгнула в блок catch!
Ошибка! Нельзя делить на ноль!
Несколько блоков catch
Блоков catch может быть несколько.

Если код в блоке try может выбросить не один, а несколько видов исключений, для каждого из них можно написать свой блок catch.

int[] numbers = {1, 2, 3, 4};
try {
for (int i = 0; i <= numbers.length; ++i) {
System.out.println(5.0 / (3 - numbers[i]));
}
} catch (ArithmeticException e) {
System.out.println("Ошибка! Деление на 0!");
} catch (ArrayIndexOutOfBoundsException e) {
System.out.println("Ошибка! Программа вышла за границы массива!");
}

**Проверяемые (checked) и непроверяемые (unchecked) исключения **
У всех исключений есть общий класс-предок Throwable.

От него происходят две большие группы — исключения (Exception) и ошибки (Error).

Разновидности ошибок и исключений

Error — это критическая ошибка во время исполнения программы, связанная с работой виртуальной машины Java. В большинстве случаев Error не нужно обрабатывать, поскольку она свидетельствует о каких-то серьезных недоработках в коде.

Наиболее известные ошибки: StackOverflowError — возникает, например, когда метод бесконечно вызывает сам себя, и OutOfMemoryError — возникает, когда недостаточно памяти для создания новых объектов.

Как видишь, в этих ситуациях чаще всего обрабатывать особо нечего — код просто неправильно написан и его нужно переделывать.

Exceptions — это, собственно, исключения: исключительная, незапланированная ситуация, которая произошла при работе программы.

Это не такие серьезные ошибки, как Error, но они требуют нашего внимания.

В Java все исключения делятся на два типа – контролируемые/проверяемые (checked) и неконтролируемые/непроверяемые (unchecked): те, которые перехватывать обязательно, и те, которые перехватывать не обязательно. По умолчанию – все исключения обязательно нужно перехватывать.

В своем коде ты сам можешь выкидывать исключения. Ты даже можешь написать свои собственные исключения. Но это мы разберем позже. Сейчас же давай научимся работать с исключениями, которые выбрасывает Java-машина.

О проверяемых исключениях мы обязаны предупредить в коде, для этого используется служебное слово throws:

public static void main() throws IOException
Чтобы программа скомпилировалась, метод, который вызывает method1 в примере ниже, должен сделать две вещи: или перехватить эти исключения или пробросить их дальше (тому, кто его вызвал), указав их в своём заголовке.

Ты уже сталкивался с несколькими непроверяемыми исключениями: ArithmeticException возникает при делении на ноль ArrayIndexOutOfBoundsException возникает при попытке обратиться к ячейке за пределами массива.

Теоретически, конечно, создатели Java могли бы ввести обязательную обработку таких исключений, но во что бы тогда превратился код? При любой операции деления чисел пришлось бы писать try-catch для проверки — не на ноль ли ты случайно делишь? При любом обращении к массиву надо было бы писать try-catch чтобы проверить, не вышел ли ты за эти пределы.

Любой написанный код был бы совершенно нечитаемым. Логично, что от этой идеи отказались.

Поэтому непроверяемые исключения не нужно обрабатывать в блоках try-catch или пробрасывать наверх, хотя технически это возможно, как и с Error.

Оператор finally
В завершение мы поговорим о блоке finally. Это последняя часть триумвирата обработки исключений try-catch-finally.

Его особенность в том, что он выполняется при любом сценарии работы программы.

Если код в блоке try выполнится целиком и не выбросит исключения, в конце сработает блок finally.

Если код внутри try прервется, и программа перепрыгнет в блок catch, после того, как отработает код внутри catch, все равно будет выбран блок finally.

Зачем он нужен?

Его главное назначение — выполнить обязательную часть кода; ту часть, которая должна быть выполнена независимо от обстоятельств.

Например, в нем часто освобождают какие-то используемые программой ресурсы.

Проект Садовод-любитель, см код занятия. Решить задачу не обязательно полностью, достаточно написать например родительский класс или часть кода в нескольких классах.
Выполнение проекта полностью - задача со звездочкой

code/main35/src/InvalidWeightException.java
public class InvalidWeightException extends Exception{

    public InvalidWeightException( String s){
        super(s);
    }
}
code/main35/src/Main.java
import java.io.IOException;

public class Main {

    /*
    Поймать исключение (с выводом на экран его типа),которое возникает при выполнении следующего кода
int a = 40/0

Поймать исключение (с выводом на экран его типа),которое возникает при выполнении следующего кода
String s =null;
String m = s.toLowerCase()

Поймать исключение (с выводом на экран его типа),которое возникает при выполнении следующего кода
int[] m = new int[2]
m[8]=5
     */

    public static void main(String[] args){
        //1.
     try{
        int a = 40/0;
        System.out.println(a);
     }catch (ArithmeticException e){
    //     System.out.println("Division by zero is forbidden");
    //     System.out.println(e.getMessage());
     }

     //2. NullPointerException
        try {
            String s = null;
            String m = s.toLowerCase();
        }catch(NullPointerException exception){
      //      System.out.println("Method can't be called on null");
        }


        //3
        try {
            int[] m = new int[2];
            m[8] = 5;
        } catch (ArrayIndexOutOfBoundsException e){
     //       System.out.println(e.getMessage());
        }

     //   throw -  используется для того, чтобы бросить exception

    //    throws - мспользуется в сигнатуре метода и указывает на то, что метод может бросить исключение.

        // throw
        // throw new exception_class("error message");
       // throw new ArithmeticException("dividing by 5 is forbidden");

        //  напишем метод, проверяющий что при приеме новых членов в детский клуб дзюдо их вес не
        // меньше 30 кг а возраст не меньше 10 лет
     //   checkAgeWeight(9,20);

        try {
            Main m = new Main();
      //      m.myMethod(1);
        }catch (Exception ex) {
     //      System.out.println(ex.getMessage());
        }
        try {
            throw new MyException("This is my exception");
        } catch (MyException e){
            System.out.println(e);
        }
    }
    public static void checkAgeWeight(int age, int weight){
        if(age<10 && weight<30){
            throw new ArithmeticException("The person is not eligible for registration");
        }
        else {
            System.out.println("Welcome aboard");
        }
    }

    //throws
    void myMethod(int number ) throws IOException,ClassNotFoundException{
        if(number == 1)
            throw new IOException("IOException occured");
        else
            throw new ClassNotFoundException("ClassNotFoundException");
    }




}
code/main35/src/Main1.java
public class Main1 {

    public static void main(String[] args) {
        Main1 m = new Main1();

        try {
            m.weightCheck(5);
        } catch (InvalidWeightException e){
            System.out.println(e.getMessage());

        }

    }

    public void weightCheck(int weight) throws InvalidWeightException{
        if( weight < 10) {
            throw new InvalidWeightException("The product is not heavy enough");
        }
        }
    }

code/main35/src/MyException.java
public class MyException extends Exception{

  public  String str;

  public MyException(String str){
      this.str = str;
  }

  public String toString(){
      return ("MyException occured:"+str);
  }
}
code/my_garden/src/Main.java
public class Main {

    // Садовод-любитель.
    /*
    Будем выращивать деревья и цветы. Каждый из этих видов  имеет следующие
    характеристики: displayName, height, age. Каждый из них  вырастает за сезон на разную высоту, одинаковую
     при этом для всех деревьев и всех цветов.
     Каждый сезон состоит из четырех времен года, в течение которых цветы и деревья ведут себя не всегда одинаково:
     Сезон для цветов начинается весной и они растут, зимой они не растут, летом они не растут а цветут, осенью их срезают.
     Для деревьев сезон начинается весной и они растут, зимой они не растут, летом растут, осенью не растут.
     В классе Main(Garden)  нужно создать метод growPlants, в котором должен быть отражен процесс роста нескольких
     растений в течение нескольких лет. Что происходит с растеним зимой, летом, весной и осенью, их размер в
     каждый сезон и какого они размера и возраста в конце.

     /*
     1. Будем решать задачу используя свойства наследования в джаве.
       Создадим родительский абстрактный класс Plant и наследующие его классы Flower  и  Tree
       В родительском классе будут три поля, общие для всех классов  displayName, height, age
       и методы, описывающие поведение растений в каждое время года. Причем когда поведение одинаковое ( весна и зима)
       методы будут общие для обоих дочерних классов и содержатся только в родительском классе. А когда поведение
       будет разное ( лето, осень), то методы будут в родительском классе абстрактные и реализованы должны быть в
       дочерних классах.
       В дочерних классах кроме методов, реализующих поведение летом и осенью, должно также быть указано насколько
       обьекты данного класса вырастают за сезон. Скорее всего в виде константы
       private final static int TREE_GROWW_PER_SEASON = 5
       Поэтому в родительском классе нужно сделать еще один абстрактный метод getGrowPerSeason,  а в дочерних
       классах реализовать его  в виде геттеров.
       Обнулить высоту  цветка можно через сеттер setHeight(0)
       В классе Garden:  нужно создать один цветок и одно дерево, поместить их в массив plants.
       В  методе growPlants нужно в цикле for  пройти по элементам массива plants поочередно вызывая методы наших
       деревьев и цветов в правильной последовательности,т.е.
       plant.doSpring()
             doSummer()
             doAutumn()
             doWinter()
     */














}