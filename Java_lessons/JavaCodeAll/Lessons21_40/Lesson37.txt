Задачи на урок:
Обсуждение и разбор дз
Сложность алгоритмов, О-нотация
Практика, решение задач
Асимптотический анализ
Когда мы говорим об измерении сложности алгоритмов, мы подразумеваем анализ времени, которое потребуется для обработки очень большого набора данных. Такой анализ называют асимптотическим. Сколько времени потребуется на обработку массива из десяти элементов? Тысячи? Десяти миллионов? Если алгоритм обрабатывает тысячу элементов за пять миллисекунд, что случится, если мы передадим в него миллион? Будет ли он выполняться пять минут или пять лет? Не стоит ли выяснить это раньше заказчика?

Все решают мелочи!

Порядок роста
Порядок роста описывает то, как сложность алгоритма растет с увеличением размера входных данных. Чаще всего он представлен в виде O-нотации (от нем. «Ordnung» — порядок) : O(f(x)), где f(x) — формула, выражающая сложность алгоритма. В формуле может присутствовать переменная n, представляющая размер входных данных. Ниже приводится список наиболее часто встречающихся порядков роста, но он ни в коем случае не полный.

Константный — O(1)
Порядок роста O(1) означает, что вычислительная сложность алгоритма не зависит от размера входных данных. Следует помнить, однако, что единица в формуле не значит, что алгоритм выполняется за одну операцию или требует очень мало времени. Он может потребовать и микросекунду, и год. Важно то, что это время не зависит от входных данных.

Линейный — O(n)
Порядок роста O(n) означает, что сложность алгоритма линейно растет с увеличением входного массива. Если линейный алгоритм обрабатывает один элемент пять миллисекунд, то мы можем ожидать, что тысячу элементов он обработает за пять секунд.

Такие алгоритмы легко узнать по наличию цикла по каждому элементу входного массива.
Логарифмический — O(log n)
Порядок роста O(log n) означает, что время выполнения алгоритма растет логарифмически с увеличением размера входного массива.

Квадратичный — O(n^2)
Время работы алгоритма с порядком роста O(n^2) зависит от квадрата размера входного массива. Несмотря на то, что такой ситуации иногда не избежать, квадратичная сложность — повод пересмотреть используемые алгоритмы или структуры данных.

Используя принципы отбрасывания констант и оставления только максимально быстро растущего элемента найти асимптотики для следующих функций:

f(n) = 9n +73
f(n) = 235
f(n) = n^2 + 7n +123
f(n) = n^3 +2000n +8765
f(n) = n + sqrt(n)
code/main37/src/Main.java
public class Main {

    public static void main(String[] args) {
                    //    0         1       2
        int[][] table ={ {5,7,3},{2,4,5},{9,5,8} };
        System.out.println(numberOfEven2Dim(table));
   //     System.out.println(table[0][0]);
   //     System.out.println(table[0][1]);
   //     System.out.println(table[0][2]);
    //    System.out.println(Arrays.toString(table[0]));
    //    System.out.println(Arrays.toString(table[1]));
    //    System.out.println(Arrays.toString(table[2]));

        for( int i=0;i<table.length;i++){
   //         System.out.println(Arrays.toString(table[i]));
   //         System.out.println("length of "+i+" subarray is "+table[i].length);
        }

    }

    /*
    Задача на повторение двумерных массивов
Написать метод, принимающий двумерный массив целых чисел и возвращающий количество четных чисел в нем.
public static int numberOfEven2Dim (int[][]numbers)
     */
    public static int numberOfEven2Dim (int[][]numbers){
        int counter = 0;  //  считает количество четных чисел в двумерном массиве

        for (int i = 0; i<numbers.length;i++){ //  цикл идет по строчкам(элементам) двумерного массива

            for (int j = 0;j<numbers[i].length;j++){
                if( numbers[i][j] % 2 == 0)
                    counter++;
            }

        }
        return counter;
    }


}
code/o_notation/src/Main.java
public class Main {

    /*
    Сложность алгоритмов.

    Cложность алгоритма - это всего лишь способ измерить  насколько быстро программа работает
    Алгоритмы сравниваются с точки зрения того, как происходит вычисление, без учета железа или языка прграммирования
    на котором программа написана

    Анализ сложности позволяет узнать  насколько быстрой является программа при выполнении вычислений и позволяет
    обьяснить как будет вести себя алгоритм при возрастании входного потока данных
     */
    public static void main(String[] args) {
        drawTriangle(5);
        char theta = '\u03f4';
        System.out.println(theta);
    }

    // {1,2,3,4}
    // 4,3,2,1
    public int max ( int[]ints,int n){
        int max = ints[0]; // 2 действия. Поиск ints[0]  и присвоение. Выполняются всегда, независимо от размера массива

        for( int i = 0;i<n;i++){ //  присвоение начального значения и сравнение с n  тоже всегда выполняются = еще 2
            if(ints[i]>max){
                max = ints[i];
            } // на каждой итерации цикла происходят еще 2 действия - увеличение i  и сравнение с n
        }
        return max;
    }

    // без учета содержимого в теле цикла количество инструкций у этого алгоритма 4 + 2n
    // f(n)= 4 + 2n   для цикла с пустым телом
    // 4 + 2n+4n   - это количество команд с учетом тела цикла в наихудшем случае, когда тело if  выполняется
    // каждый раз
    /*
    f(n) = 4 +6n

    В анализе сложности важно то, что происходит с функцией при сильном возрастании n. Поэтому мы можем отбросить
    те части функции, которые при сильном росте n растут медленно или совсем не растут. Поэтому 4 мы отбрасываем,
    т.к. это константа

    f(n) = 6n // 6 тоже отбрасываем

    f(n) = n

    1. f(n) = 3n +15    ->  f(n) = n
    2. f(n) = 214       ->   f(n) = 1   // 214*1 и 214 отбравсываем
    3. f(n) = n^2 + 4n + 54   f(n) = n^2
    4. f(n) = n^3 + 2100n + 582    f(n) = n^3
    5. f(n) = n +sqrt(n)           f(n) = n

    //Сложность
     */

    public boolean linSearch ( int[] arr,int eltToFind){
        for(int i = 0; i < arr.length;i++){
            if(arr[i] == eltToFind)
                return true;
        }
        return false;
    }

    public int sum( int a, int b){
        int res = a+b;

        return res;
    }

    public static void drawTriangle(int n){
        for( int i = 1;i<=n;i++){
            for( int j=1;j<=i;j++){
                System.out.print(j);

            }
            System.out.println();
        }
    }

    // простые программы можно анализировать с помощью подсчета в них количества вложенных циклов.
    // одиночный f(n) = n,    цикл внутри цикла f(n) = n^2  , и т.д

    //ϴ(1),  f(n)= 2n +1   ->  ϴ(n)

   // Нотация  "большое О "

}
code/var_variables/src/Main.java
public class Main {
    public static void main(String[] args) {
        int i;
        i= 1;
        var j = 9; //  как ключевое слово
        //j="str"

        int var =56; // как имя переменной
        var number = -var; // переменной number будет присвоено значение переменной var (56)

        int a = 56;
        number =-a;

        var myArray = new int[10]; // можно использовать var для обьявления массива. Квадратные скобки с левой стороны
                                    // при эт ом не ставятся
        int[] arr = new int[10];

        // var можно использовать для обьявления только локальных переменных, а не полей класса . Его также
        // нельзя использовать с return.

        var myString = "This is a string";
        var mySubString = myString.substring(1,3);

        var myClass = new OurVarClassExample(5);
        myClass.setI(78);
        System.out.println(myClass.getI());

      //  FileOutputStream

        for( var k = 0; k<100;k++); //  можно использовать в циклах
        for (var v:myArray);
      //  var n = null;   так нельзя
      //  var arr1 = {1,2,3}; так тоже нельзя



    }
}
code/var_variables/src/OurVarClassExample.java
public class OurVarClassExample {
  private int i;

    public OurVarClassExample(int i) {
        this.i = i;
    }

    public int getI() {
        return i;
    }

    public void setI(int i) {
        this.i = i;
    }
}